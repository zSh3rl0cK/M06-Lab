# -*- coding: utf-8 -*-
"""ATV_5_Pedro_Henrique_Ribeiro_Dias.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xn8B-BuNDdaZnY_YEorCRxtCQa1UoX51

## Nome: Pedro Henrique Ribeiro Dias
## Matricula: 529

---

## **Atividade 5** - Localização e Refinamento de Raízes

## Funções Auxiliares
"""

# Plotar gráficos
import seaborn as sns
import matplotlib.pyplot as plt

# Analise de dados
import numpy as np
import pandas as pd

"""### Função e Derivada da Função"""

def target_function(x):
    return x**3 - 2*x**2 - 3*x + 1

def derivative_function(x):
    return 3*x**2 - 4*x - 3

intervalo = [-5, 5]

"""### Método de Newton-Raphson"""

# implementa o processo de iteração usando a fórmula de Newton-Raphson
def newton_raphson_method(initial_guess, tolerance, max_iterations):
    """
    Aplica o método de Newton–Raphson para aproximar uma raiz de target_function(x).

    :param initial_guess: chute inicial x0
    :param tolerance: tolerância para parada (critério |f(x)| < tolerance)
    :param max_iterations: número máximo de iterações
    :return: raiz aproximada (float), número de iterações (int)
    """
    x_n = initial_guess
    for iteration in range(max_iterations):
        f_x = target_function(x_n)
        f_prime_x = derivative_function(x_n)

        # Evitar divisão por zero
        if f_prime_x == 0:
            print("A derivada é zero. Não é possível prosseguir.")
            return x_n, iteration + 1 # Retornar a aproximação atual e a contagem de iterações

        # Verificar convergência com base na tolerância
        if abs(f_x) < tolerance:
            return x_n, iteration + 1 # Retornar a raiz e a contagem de iterações

        x_n = x_n - f_x / f_prime_x

    # Se o número máximo de iterações for atingido sem convergência
    print("Número máximo de iterações atingido sem alcançar a tolerância desejada.")
    return x_n, max_iterations

"""---

## Parte Prática
No Inatel, os alunos de engenharia muitas vezes precisam analisar funções matemáticas para resolver problemas práticos, como verificar o comportamento de circuitos, sinais ou sistemas de controle. Encontrar as raízes de uma função é um passo importante nesses contextos, pois pode indicar pontos de equilíbrio, frequências de ressonância ou condições de operação de um sistema.

Seja a função
$f(x) = x^3 – 2x^2 – 3x + 1$.

Sabendo que esta função possui raízes no intervalo [−5,5], utilize o TEU com espaçamento de 1 para localizar os intervalos que contêm cada uma das raízes reais da função.
"""

df = pd.DataFrame(columns=["x", "f(x)", "f1(x)"])
for x in range(intervalo[0], intervalo[1]+1):
    df = pd.concat([df, pd.DataFrame({"x": [x], "f(x)": [target_function(x)], "f1(x)": [derivative_function(x)]})]).reset_index(drop=True)

print(df.to_string(index=False))

"""1. Utilizando o Teorema do Valor Intermediário (TEU) e espaçamento unitário no intervalo [−5,5], determine os subintervalos que contêm cada uma das raízes reais da função."""

def mudou_sinal(fa, fb):
    # TEU: existe raiz em [a,b] se f é contínua e fa*fb < 0
    return fa * fb < 0

intervalos = [-5,5]
chutes_iniciais = []
for x in range(df.shape[0]-1):
    x_a, x_b = df.loc[x, "x"], df.loc[x+1, "x"]
    f_a, f_b = df.loc[x, "f(x)"], df.loc[x+1, "f(x)"]
    # 1. Verificar se há mudança de sinal na função
    if mudou_sinal(f_a, f_b):
    # 2. Escolher os chutes iniciais para Newton-Raphson (utilize o ponto médio do intervalo)
      chute = (x_a + x_b) / 2
      chutes_iniciais.append(chute)
    continue

print("Chutes iniciais encontrados:", chutes_iniciais)

"""2. Identifique visualmente os pontos onde a curva cruza o eixo x e compare com os intervalos obtidos pelo TEU."""

# Plotando o grafco da funcao
plt.figure(figsize=(8,6))
plt.plot(df["x"], df["f(x)"])

plt.show()

"""3. Implemente o Método de Newton-Raphson nos pontos iniciais obtidos."""

tolerancia = 1e-9
iteracao_max = 250

# Obtendo as raizes aproximadas com os chutes
for chute in chutes_iniciais:
    raiz, iteracoes = newton_raphson_method(chute, tolerancia, iteracao_max)
    print("\nRaízes aproximadas:", raiz)

"""4. Implemente o Método de Bissecção"""

# faznedo uma funcao para o metodo da bisseccao
def bisseccao(f, a, b, tol=1e-9, max_iter=100):
    fa, fb = f(a), f(b)

    for k in range(1, max_iter+1):
        # ponto médio
        m = (a + b) / 2
        fm = f(m)

        # critério de parada
        if abs(fm) < tol or (b - a)/2 < tol:
            return m, k

        # escolher o subintervalo
        if fa * fm < 0:
            b, fb = m, fm
        else:
            a, fa = m, fm

    # se não convergiu
    print("Número máximo de iterações atingido sem convergência.")
    return (a + b) / 2, max_iter

# Função para calcular os valores
def target_function(x):
    return x**3 - 2*x**2 - 3*x + 1

raizes_bisseccao = []
for x in range(df.shape[0]-1):
    x_a, x_b = df.loc[x, "x"], df.loc[x+1, "x"]
    f_a, f_b = df.loc[x, "f(x)"], df.loc[x+1, "f(x)"]

    if mudou_sinal(f_a, f_b):
        raiz, iteracoes = bisseccao(target_function, x_a, x_b, tol=1e-9, max_iter=250)
        raizes_bisseccao.append(raiz)

print("\nRaízes aproximadas pelo método da bissecção:", raizes_bisseccao)

"""---
## Parte Teórica

1. Quais são as limitações do uso do TEU para encontrar raízes de funções?

Resposta:
É necessário que a função seja contínua no intervalo de [a,b]
Não garante unicidade, pode haver mais de uma raíz dentro do intervalo
Não localiza a raiz exata da função

2. Qual é a principal vantagem do método da bissecção em relação a outros métodos numéricos?

Resposta: Sua vantagem é que ele sempre converge para uma raiz, desde que a função seja contínua no intervalo e tenha mudança de sinal.

3. Em quais situações o método de Newton-Raphson pode falhar ou não convergir?

Resposta: Pode falhar ou não convergir se o chute inicial for ruim, estando muito longe da raiz. Caso a derivada da função não seja contínua também poderá falhar e por fim, caso a derivada da função resulte em um valor nulo, ocasionando uma divisão por 0 no método.
"""