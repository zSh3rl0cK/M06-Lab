# -*- coding: utf-8 -*-
"""ATV6_Pedro_Henrique_Ribeiro_Dias.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vL-9k53Aem1DRzCpSYtH9sr1NDE_ezaR

## Nome: Pedro Henrique Ribeiro Dias
## Matricula: 529

## **Atividade 6** - Métodos Iterativos de Jacobi e de Gauss-Seidel

## Funções Auxiliares
"""

# Plotar gráficos
import seaborn as sns
import matplotlib.pyplot as plt

# Analise de dados
import numpy as np
import pandas as pd

"""### Método de Gauss-Seidel"""

# Implementa o processo de iteração usando o método de Gauss-Seidel
def gauss_seidel_method(A, b, initial_guess=None, tolerance=1e-6, max_iterations=100):
    """
    Aplica o método de Gauss-Seidel para resolver sistemas lineares Ax = b.

    :param A: matriz dos coeficientes (numpy array)
    :param b: vetor de constantes (numpy array)
    :param initial_guess: chute inicial (vetor, opcional)
    :param tolerance: critério de parada (diferença máxima entre iterações consecutivas)
    :param max_iterations: número máximo de iterações
    :return: vetor solução aproximada (numpy array), número de iterações realizadas (int)
    """
    n = len(b)
    x = np.zeros_like(b, dtype=float) if initial_guess is None else initial_guess.astype(float)

    for iteration in range(max_iterations):
        x_new = np.copy(x)

        for i in range(n):
            soma_antes = np.dot(A[i, :i], x_new[:i])   # valores já atualizados
            soma_depois = np.dot(A[i, i+1:], x[i+1:])  # valores antigos
            x_new[i] = (b[i] - soma_antes - soma_depois) / A[i, i]

        # critério de parada
        if np.linalg.norm(x_new - x, ord=np.inf) < tolerance:
            return x_new, iteration + 1

        x = x_new

    return x, max_iterations

"""### Método de Gauss-Jacobi"""

def jacobi(A, b, chute_inicial=None, tolerancia=1e-6, max_iteracoes=100):
    """
    Resolve Ax = b pelo método de Jacobi.
    """
    n = len(b)
    x = np.zeros_like(b, dtype=float) if chute_inicial is None else chute_inicial.astype(float)

    for k in range(max_iteracoes):
        x_novo = np.zeros_like(x, dtype=float)

        for i in range(n):
            soma = 0
            for j in range(n):
                if j != i:
                    soma += A[i][j] * x[j]   # aqui usa APENAS os valores da iteração anterior
            x_novo[i] = (b[i] - soma) / A[i][i]

        # critério de parada
        if np.linalg.norm(x_novo - x, ord=np.inf) < tolerancia:
            return x_novo, k + 1

        x = x_novo

    return x, max_iteracoes

"""---

## Parte Prática

!!! O principal objetivo da parte prática, será a resolução e a compreensão de sistemas lineares usando os métodos de Gauss-Seidel e de Jacobi

Abaixo, terá para vocês, o sistema no formato matricial e no formato clássico de um sistema. Ambas as formas podem ser usadas para representar um sistema de Equação!
"""

# Saida na forma Matricial
A = [
    [4,1,2],
    [3,5,1],
    [1,1,3]
]
b = [4,7,3]

df = pd.DataFrame(A, columns=["X", "Y", "Z"])
df["="] = b
print(df.to_string(index=False))

sistema = f"""
⎧ 4x + y + 2z = 4
⎨ 3x + 5y + z = 7
⎩ x + y + 3z = 3
"""
print(sistema)

"""---

1-Resolva o sistema acima utilizando o método de Gauss-Seidel até atingir uma precisão de 10^-6:
"""

#Resolva aqui a questão 1, usando como base, o código fornecido à respeito de método de Gauss-Seidel, fornecido no início do Notebook

A = np.array([[4,1,2],[3,5,1],[1,1,3]])
b = np.array([4,7,3])
solucao, iteracoes = gauss_seidel_method(A, b, np.zeros_like(b), 1e-6, 100)
print(solucao)
print("iterações:", iteracoes)

"""2- Resolva o mesmo sistema acima, porém utilizando o método de Gauss-Jacobi até atingir uma precisão de 10^-6"""

#Resolva aqui a questão 2, usando como base, o código fornecido à respeito de método de Gauss-Jacobi, fornecido no início do Notebook

A = np.array([[4,1,2],[3,5,1],[1,1,3]])
b = np.array([4,7,3])
solucao, iteracoes = jacobi(A, b, np.zeros_like(b), 1e-6, 100)
print(solucao)
print("iterações:", iteracoes)

"""---
## Parte Teórica

1.Explique com suas próprias palavras, a principal diferença entre o método de Jacobi e o método de Gauss-Seidel.

Resposta:
No Jacobi, ao fazer uma nova iteração ela usará apenas os valores da iteração anterior para calcular todos os elementos de x.

No Gauss-Seidel, valores calculados de x em uma mesma iteração já são usados nos próximos cálculos

2. O que é uma matriz estritamente diagonalmente dominante?

    Explique sua importância para a convergência dos métodos iterativos Jacobi e Gauss-Seidel.

Resposta:
Uma matriz será estritamente diagonalmente dominante quando em suas linhas módulo do elemento que pertence à diagonal principal for maior do que a soma dos módulos dos outros elementos dela

Isso é importante porque garante de que os métodos de Jacobi e Gauss-Seidel converjam para a solução certa

3. Explique com suas próprias palavras a principal diferença entre uma solução exata e uma solução aproximada de um sistema linear.

Resposta: Solução exata: é o resultado que resolve perfeitamente o sistema, de forma direta

Solução aproximada: é um valor próximo da solução exata, calculado com uma precisão específica.
"""